%{

#include "FlexActions.h"

static YY_BUFFER_STATE importedExpressionBufferState = NULL;

%}

/**
 * Enable start condition manipulation functions.
 */
%option stack
%option case-insensitive

/**
 * Flex contexts (a.k.a. start conditions).
 *
 * @see https://westes.github.io/flex/manual/Start-Conditions.html
 * %x IMPORT_EXPRESSION
 */
%x MULTILINE_COMMENT

/**
 * Reusable patterns.
 *
 * @see https://westes.github.io/flex/manual/Matching.html
 * @see https://westes.github.io/flex/manual/Patterns.html
 */

%%

"/*"										{ BEGIN(MULTILINE_COMMENT); BeginMultilineCommentLexemeAction(createLexicalAnalyzerContext()); }
<MULTILINE_COMMENT>"*/"						{ EndMultilineCommentLexemeAction(createLexicalAnalyzerContext()); BEGIN(INITIAL); }
<MULTILINE_COMMENT>[[:space:]]+				{ IgnoredLexemeAction(createLexicalAnalyzerContext()); }
<MULTILINE_COMMENT>[^*]+					{ IgnoredLexemeAction(createLexicalAnalyzerContext()); }
<MULTILINE_COMMENT>.						{ IgnoredLexemeAction(createLexicalAnalyzerContext()); }

"CREATE" 									{ return TextLexemeAction(createLexicalAnalyzerContext(), CREATE); }
"TABLE" 									{ return TextLexemeAction(createLexicalAnalyzerContext(), TABLE); }

"NOT" 										{ return BooleanLexemeAction(createLexicalAnalyzerContext(), NOT); }

"NULL"										{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), NUL); }
"CHECK" 									{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), CHECK); }
"PRIMARY" 									{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), PRIMARY); }
"FOREIGN" 									{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), FOREIGN); }
"KEY" 										{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), KEY); }
"UNIQUE"				 					{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), UNIQUE); }
"CONSTRAINT"								{ return ConstraintLexemeAction(createLexicalAnalyzerContext(), CONSTRAINT); }

"INTEGER|INT"	  							{ return TypeLexemeAction(createLexicalAnalyzerContext(), INTEGER); }
"SMALLINT"									{ return TypeLexemeAction(createLexicalAnalyzerContext(), SMALLINT); }
"BIGINT"									{ return TypeLexemeAction(createLexicalAnalyzerContext(), BIGINT); }
"REAL"										{ return TypeLexemeAction(createLexicalAnalyzerContext(), REAL); }
"DOUBLE"									{ return TypeLexemeAction(createLexicalAnalyzerContext(), DOUBLE); }
"DATE"										{ return TypeLexemeAction(createLexicalAnalyzerContext(), DATE); }
"TIMESTAMP"									{ return TypeLexemeAction(createLexicalAnalyzerContext(), TIMESTAMP); }		
"INTERVAL"									{ return TypeLexemeAction(createLexicalAnalyzerContext(), INTERVAL); }
"TEXT"										{ return TypeLexemeAction(createLexicalAnalyzerContext(), TEXT); }
"CHAR|CHARACTER"							{ return TypeLexemeAction(createLexicalAnalyzerContext(), CHAR); }		
"VARCHAR|CHAR VARYING|CHARACTER VARYING"	{ return TypeLexemeAction(createLexicalAnalyzerContext(), VARCHAR); }
"NUMBER|DECIMAL|DEC"						{ return TypeLexemeAction(createLexicalAnalyzerContext(), NUMBER); }
"FLOAT"										{ return TypeLexemeAction(createLexicalAnalyzerContext(), FLOAT); }
"TIME"										{ return TypeLexemeAction(createLexicalAnalyzerContext(), TIME); }

"("											{ return ParenthesisLexemeAction(createLexicalAnalyzerContext(), OPEN_PARENTHESIS); }
")"											{ return ParenthesisLexemeAction(createLexicalAnalyzerContext(), CLOSE_PARENTHESIS); }
","											{ return ComaLexemeAction(createLexicalAnalyzerContext(), COMA); }
";"					 						{ return SemicolonLexemeAction(createLexicalAnalyzerContext(), SEMICOLON); }




<<EOF>>										{
												printf("%s", "[FlexPatterns] EOF, poping buffer.\n");
												yypop_buffer_state();
												if (!YY_CURRENT_BUFFER) {
													// Signals Bison to stop the parsing if there is no more input buffers in the stack.
													yyterminate();
												}
											}
									
[0-3][0-9]"/"[0-1][0-9]"/"[0-9][0-9]			{ return DateTimeLexemeAction(createLexicalAnalyzerContext(), DATE_VALUE); }
[0-3][0-9]"/"[0-1][0-9]"/"[0-9][0-9] [00-9]  	{ return DateTimeLexemeAction(createLexicalAnalyzerContext(), TIMESTAMP_VALUE); }
((0?[0-9])|[0-9]{2})":"((0?[0-9])|[0-9]{2})		{ return DateTimeLexemeAction(createLexicalAnalyzerContext(), TIME_VALUE); }
[[:digit:]]+","[[:digit:]]+ 					{ return DoubleLexemeAction(createLexicalAnalyzerContext(), DOUBLE_VALUE); }

[[:alnum:]"_"]+									{ return IdLexemeAction(createLexicalAnalyzerContext()); }

[[:digit:]]+									{ return IntegerLexemeAction(createLexicalAnalyzerContext()); }

[[:space:]]+									{ IgnoredLexemeAction(createLexicalAnalyzerContext()); }
"\n"											{ IgnoredLexemeAction(createLexicalAnalyzerContext()); }
.												{ return UnknownLexemeAction(createLexicalAnalyzerContext()); }

%%

#include "FlexExport.h"

/**
*
*
*
* "-"									{ return ArithmeticOperatorLexemeAction(createLexicalAnalyzerContext(), SUB); }
* "*"									{ return ArithmeticOperatorLexemeAction(createLexicalAnalyzerContext(), MUL); }
* "/"									{ return ArithmeticOperatorLexemeAction(createLexicalAnalyzerContext(), DIV); }
* "+"									{ return ArithmeticOperatorLexemeAction(createLexicalAnalyzerContext(), ADD); }
*
* <IMPORT_EXPRESSION>[^{}]+			{
* 										LexicalAnalyzerContext * lexicalAnalyzerContext = createLexicalAnalyzerContext();
* 										printf("[FlexPatterns] Creating next buffer to consume from file '%s'.\n", lexicalAnalyzerContext->lexeme);
* 										yyin = fopen(lexicalAnalyzerContext->lexeme, "r");
* 										importedExpressionBufferState = yy_create_buffer(yyin, YY_BUF_SIZE);
*										destroyLexicalAnalyzerContext(lexicalAnalyzerContext);
*									}
*
* <IMPORT_EXPRESSION>"}"				{
*										printf("%s", "[FlexPatterns] Loading next buffer from imported expression.\n");
*										yypush_buffer_state(importedExpressionBufferState);
*										BEGIN(INITIAL);
*									}
*
* <IMPORT_EXPRESSION>.				{
*										printf("%s", "[FlexPatterns] Syntax error inside import expression.\n");
*										return UnknownLexemeAction(createLexicalAnalyzerContext());
*									}
*"{"									{
*										printf("%s", "[FlexPatterns] Context-switch to IMPORT_EXPRESSION.\n");
*										BEGIN(IMPORT_EXPRESSION);
*									}
**/
